**[назад](sort)**

# Быстрая сортировка [Quicksort]

[filename](short/quicksort.md ':include')

#### сложность алгоритма:
- Худший случай	O(n^2)
- Лучший случай	O(n log n) (simple partition) и  O(n) (three-way partition and equal keys)
- Средний случай O(n log n)
- Худший случай по памяти O(n) auxiliary (naive) / O(log n) auxiliary (Hoare 1962)

#### принцип работы:
дробим на два массива и выбираем pivot (элемент из массива)
сортируем так чтоб в первом массиве были все числа что меньше либо равны, в правом все что больше
рекурсивно вызываем на эти два подмассива

#### Пример реализации - разбиение Ломуто:

Данный алгоритм разбиения был предложен Нико Ломуто и популяризован в книгах Бентли (Programming Pearls) и Кормена (Введение в алгоритмы).
В данном примере опорным выбирается последний элемент. Алгоритм хранит индекс в переменной i. Каждый раз, когда находится элемент, меньше или равный опорному, индекс увеличивается, и элемент вставляется перед опорным.
Хоть эта схема разбиения проще и компактнее, чем схема Хоара, она менее эффективна и используется в обучающих материалах.
Сложность данной быстрой сортировки падает до O(n2), когда массив уже отсортирован или все его элементы равны.
Существуют различные методы оптимизации данной сортировки: алгоритмы выбора опорного элемента, использование сортировки вставками на маленьких массивах. В данном примере сортируются элементы массива A от low до high (включительно)

![Gif Lomuto](../_media/img/sort/quicksort_lomuto.gif ':size=250')

[filename](../_media/examples/sort/quicksort.go ':include :type=code :fragment=lomutoQuickSort')

[ссылка на весь файл](https://github.com/proggga/training/blob/master/docs/_media/examples/sort/quicksort.go)

#### Пример реализации - разбиение Хоара:

Данная схема использует два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после.
Эти элементы меняются местами.
Обмен происходит до тех пор, пока индексы не пересекутся.
Алгоритм возвращает последний индекс.
Схема Хоара эффективнее схемы Ломуто, так как происходит в среднем в три раза меньше обменов (swap) элементов, и разбиение эффективнее, даже когда все элементы равны.
Подобно схеме Ломуто, данная схема также показывает эффективность в O(n2), когда входной массив уже отсортирован.
Сортировка с использованием данной схемы нестабильна.
Следует заметить, что конечная позиция опорного элемента необязательно совпадает с возвращённым индексом.

![Gif Hoare](../_media/img/sort/quicksort_hoare.gif)

[filename](../_media/examples/sort/quicksort.go ':include :type=code :fragment=hoareQuickSort')

[ссылка на весь файл](https://github.com/proggga/training/blob/master/docs/_media/examples/sort/quicksort.go)

#### Пример реализации - разбиение Ломуто, но без рекурсии:

чтоб победить stackoverflow есть вариант работы без рекурсии, индексы low и high помещают в [stack](structs/stack.md), и работаем в цикле наполняя и вытаскивая из стека, главное что без рекурсии

[filename](../_media/examples/sort/quicksort.go ':include :type=code :fragment=iterativeLomutoQuickSort')

[ссылка на весь файл](https://github.com/proggga/training/blob/master/docs/_media/examples/sort/quicksort.go)


