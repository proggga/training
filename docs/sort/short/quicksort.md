При сортировке выбирается значение (pivot), массив разбивается на два, где все значения перемещаются первый или второй массив. В первый попадают значения, которые меньше чем pivot. Во второй все, которые больше чем pivot, и дальше этот же алгоритм рекурсивно вызывается на оба массива.

#### Вики
- [Quicksort](https://en.wikipedia.org/wiki/Insertion_sort)
- [Быстрая сортировка](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)

#### quick_sort основное:
- in-place может сортировать без доп памяти
- имеет много нюансов и при неправильной реализации может дойти до stackoverflow exception, из-за глубокой рекурсии
- эффективная версия алгоритма не является стабильной (stable) - тоесть массивы с похожими ключами будут в другом порядке
- выбор pivot-а в разных реализациях сильно влияет на результат, иногда приводит к stackoverflow, самый эффективное: взять первый, средний и последний элемент, отсортировать и взять медиану в качестве pivot
- в вариации lomuto алгоритм страдает из-за отсортированных данных, чем сильнее отсортирован - тем медленнее работает доходя до n^2
- есть варианты алгоритма, которые боряться с stackoverflow - напр [Introsort](https://ru.wikipedia.org/wiki/Introsort), когда рекурсия становится слишком большой, то переходит на [heapsort](sort/heapsort.md)
- в библиотеке stdlib функция qsort для маленьких подмассивов использует [insertion sort](sort/insertion_sort.md), тк он эффективен если данные отсортированы 
- тоже для эффективности используется разбиение не на 2 подмассива, а на 3 - меньшие, равные, большие
- чтоб победить stackoverflow есть вариант работы без рекурсии, индексы low и high помещают в [stack](structs/stack.md), и работаем в цикле наполняя и вытаскивая из стека, зато без рекурсии